[{"title":"Hello, world","date":"2025-03-23T15:28:00.000Z","url":"/posts/hello-world/","tags":[["欢迎","/tags/%E6%AC%A2%E8%BF%8E/"]],"categories":[["undefined",""]],"content":"莫名想要自己写一个博客，于是开了。 第一篇文章应该做一些自我介绍一类的，等我想起来了的话把这篇变成自我介绍吧。 选用了 Kratos : Rebirth 作为博客主题。挺好看的也挺好用的。"},{"date":"2025-03-23T16:19:18.846Z","url":"/effects/leave_event.js","categories":[["undefined",""]],"content":"(() => { // 配置部分 const leaveDelay = 30; // 触发事件的延迟，单位为秒 const leaveFavicon = null; // 触发事件后的图标路径，设置为 null 表示不替换图标 const leaveTitle = \"\\u00A0Not\\u00A0a\\u00A0marionette...\\u00A0気づいてよ\\u00A0\"; // 触发事件后的标题 const returnTitle = \"\\u00A0届くと そう\\u00A0信じたいんだよ\\u00A0それが証となるって思うんだ\\u00A0\"; // 回归之后的标题 // 代码部分 let originTitle = \"\"; const saveTitle = () => { originTitle = document.title; }; let scrolling = true; function scrollTitle() { if (!scrolling) return; //document.title = title; document.title = document.title.slice(1) + document.title[0]; // Shift characters setTimeout(scrollTitle, 400); } let inactiveTimeout = null; const siteFavicon = document.querySelector('[rel=\"icon\"]'); const originFaviconUrl = siteFavicon.getAttribute(\"href\"); document.addEventListener(\"visibilitychange\", (ev) => { if (ev.target.hidden) { // 触发离开事件，开始计时 inactiveTimeout = setTimeout(() => { document.title = leaveTitle; scrollTitle(); scrolling = true; if (leaveFavicon) { siteFavicon.setAttribute(\"href\", leaveFavicon); } inactiveTimeout = null; }, leaveDelay * 1000); } else { // 触发回归事件 if (inactiveTimeout !== null) { // 还在计时，（假装）无事发生 clearTimeout(inactiveTimeout); inactiveTimeout = null; } else { // 回归了，庆祝一下 document.title = returnTitle; scrollTitle(); scrolling = true; if (leaveFavicon) { siteFavicon.setAttribute(\"href\", originFaviconUrl); } // 稍等一等再把标题改回来 setTimeout(() => { document.title = originTitle; scrolling = false; }, 10000); } } }); // 保存标题 saveTitle(); // 在 PJAX 之后再保存标题 window.addEventListener('pjax:complete', saveTitle); })();"},{"date":"2025-03-23T15:50:16.475Z","url":"/effects/cursor_effects.js","categories":[["undefined",""]],"content":"class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 10, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i < this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) => { if (circle.position.x > this.area.width || circle.position.y > this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle => circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) => { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init()"}]